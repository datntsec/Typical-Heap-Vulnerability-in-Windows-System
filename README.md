Typical Heap Vulnerability in Windows System
-
Dịch từ bài báo: [Research on Generation Principle and Utilization Method of Typical Heap Vulnerability in Windows System](https://www.jianshu.com/p/a853040d2804)

# ABSTRACT
Với sự tiến bộ của thời đại ngày nay cùng với sự phát triển khoa học và kĩ thuật, hiệu suất của máy tính cũng ngày càng phát triển (nhanh hơn, mạnh hơn), nhu cầu của mọi người đối với máy tính cá nhân cũng dần thay đổi, họ bắt đầu cần sự an toàn hơn là hiệu suất hoạt động. Đặc biệt, trong những năm gần đây, việc thường xuyên để lộ lỗ hổng bộ nhớ máy tính cá nhân đã gây nguy hiểm nghiêm trọng đến sự cố bảo mật thông tin cá nhân của người dùng, điều đó đã thúc đẩy quá trình chuyển hóa tư tưởng. Là hệ điều hành chủ đạo của máy tính cá nhân, hệ điều hành Windows gánh trên vai trọng trách chịu trách nhiệm về thông tin cá nhân của người dùng. Từ đó, bảo mật của hệ điều hành Windows liên quan trực tiếp đến bảo mật thông tin cá nhân của hầu hết mọi người.

Quản lí bộ nhớ stack trên Windows đã được nghiên cứu một cách triệt để, nó hoạt động riêng lẻ nên rất khó để có lỗ hỏng mới. Ngược lại với stack, heap có cơ chế quản lí và phương thức hoạt động tương đối phức tạp hơn.

Bài báo này sẽ khám phá lịch sử phát triển, thuật toán cơ bản, nguyên tắc hoạt động của heap trên hệ điều hành Windows và tóm tắt việc triển khai cụ thể cơ chế quản lý heap của hệ điều hành Windows tại mỗi giai đoạn mà nó tạo ra các nguyên tắc và phương pháp sử dụng của các lỗ hỏng heap điển hình. Mục tiêu là để hiểu sâu về điều cơ bản của hệ điều hành Windows thông qua giới thiệu và tóm lược, từ đó và cung cấp một số sự trợ giúp cho những người đam mê bảo mật quan tâm nhiều đến heap trên hệ điều hành Windows.

## 1. Research background
Trong những năm gần đây, lỗ hỏng trên hệ điều hành chủ đạo của máy tính cá nhân - Windows - đã lần lượt xuất hiện, đe dọa đến an toàn thông tin của người dùng. Trong đó lỗ hỏng quan trọng buffer overlow được xem là một lỗ hỏng kỳ cựu (veteran). Vì tò mò về nguyên nhân gây ra lỗ hỏng, tác giá đã bắt đầu khám phá về Windows heap buffer. Trong bộ nhớ của Windows,  là nơi bí ẩn nhất, hấp dẫn trong số các nơi hấp dẫn. Đồng thời, heap cũng là nơi đầy hỗn loạn của bộ nhớ Windows. vì Microsoft đã không tiết lộ đầy đủ các chi tiết về quản lý heap trong hệ điều hành Windows, tất cả chỉ có thể dựa vào các công cụ gỡ lỗi như `OllyDbg`, `WinDbg` và từ các tài liệu, bài viết được viết bởi các người đi trước để tiến bộ từ từ.

Hệ điều hành Windows đã trải qua nhiều năm phát triển, đi cùng với sự phát triển đó, cơ chế quản lí heap của Windows cũng đã trải qua những thay đổi lớn. Cơ chế quản lí heap hiện tại có tính đến nhiều yêu tố khác nhau chẳng hạn như việc sử dụng hiệu quả bộ nhớ của hệ điều hành Windows và hiệu quả của việc ra quyết định trong việc cấp phát/phân bổ bộ nhớ, an toàn và mạnh mẽ. Chính việc tối ưu hóa hiệu suất đã khiến cơ chế quản lí heap trên Windows trở nên cực kỳ phức tạp. Bài báo này sẽ lấy cơ chế quản lý heap trên nền tảng Win32 làm đại diện cho việc nghiên cứu sự phát triển của cơ chế quản lý heap trên hệ điều hành Windows. Từ việc nghiên cứu đó, tác giả bài báo đã chia việc nghiên cứu thành 3 giai đoạn:
  1. Windows 2000 - Windows XP SP1: Tại thời điểm này, hệ thống quản lý heap tương đối sơ khai. Nó không chú trọng đến sự an toàn của bộ nhớ heap, mà chú trọng vào việc phân bổ và cải thiện hiệu suất. Đây là giai đoạn mà vấn đề bảo mật của heap trở nên nghiêm trọng và dễ bị tấn công hơn.
  2. Windows XP SP2 - Windows 2003: Từ kinh nghiệm của giai đoạn trước, giai đoạn này, Windows chia trình quản lý heap thành hai trình quản lý khác nhau: font-end và back-end. Đồng thời họ cũng đã thêm vào nhiều biện pháp bảo vệ an toàn, ví dụ như header format của heap block được thay đổi và thêm vào một cơ chế security verification, cụ thể là cơ chế Cookie. Khi một node trong danh sách liên kết đôi được xóa, hệ thống sẽ xác minh pointer của heap block, điều này sẽ gây khó khăn hơn trong việc tấn công heap, tuy nhiên kẻ tấn công vẫn có thể sử dụng các phương thức tấn công nâng cao để khai thác thành công heap overlow vào các phần mêm chưa các code không được chuẩn hóa của lập trình viên.
  3. Windows Vista - Windows 7: Sau một thời gian dài phát triển, cơ chế quản lý font-end của heap đã được cải cách, một cơ chế quản lý heap và cấu trúc heap block mới đã được giới thiệu. Đây là một bước nhảy vọt trong hiệu quả phân phối và bảo vệ an toàn.
  
  Phẩn dưới đây sẽ giải thích chi tiết về việc chuẩn bị môi trường, cấu trúc quan trọng, cơ chế phân bổ, cơ chế bảo vệ của heap trong cả ba giai đoạn trên. Từ đó đưa ra nguyên nhân và phương pháp sử dụng các lỗ hỏng phổ biến.
  
## Windows 2000 - Windows XP SP1

### 2.1 Environmental preparation
Máy ảo Windows 2000 SP4 32-bit, OllyDbg, WinDbg.

### 2.2 Important structure
Ở giai đoạn này, toàn bộ heap space chủ yêu duy trì ở 4 structure: segment list, virtual allocation list, free list and lookaside. Trong đó, hai cấu trúc dữ liệu khác được liên kết đến một bảng trống, tên là Freelist Bitmap và Heap Cache. Sự ra đời của hai cấu trúc dữ liệu này giúp tăng tốc quá trình cấp phát qua việc giảm số lần sử dụng empty table trong quá trình cấp phát.

#### 2.2.1 Basic structure of heap
Cấu trúc heap của trạng thái bận trong giai đoạn này được biểu diễn như hình bên dưới:

![Heap block structure in occupied state](pic/pic1.PNG)

Ngược lại với hình trên, hình sau là cấu trúc heap ở trạng thái nhàn rỗi (free):

![Heap block structure in idle state](pic/pic2.PNG)

#### 2.2.2 Empty table
Trong quá trình cấp phát heap, chúng ta chủ yếu quan tâm đến các quy tắc phân bổ của empty tables và fast table, cái mà quản lý các heap block đã free. Tổng cộng có 128 danh sách liên kết đôi trong empty list. Mỗi danh sách liên kết đôi sẽ là một empty list. Trừ empty list NO. 0 và NO. 1, từ NO. 2 đến NO. 127 được duy trì từ 16 byte (bao gồm heap header) đến 1016 bytes (bao gồm heap header) với mỗi emply table sẽ tăng 8 bytes tức kích thước của mỗi heap block mà nó chứa sẽ là `empty table number * 8 bytes` (ví dụ NO. 10 sẽ chứa heap block có kích thước 10*8 = 80 bytes). Vì heap header ở trạng thái nhàn rỗi (free) luôn là 8 byte nên empty table NO. 1 sẽ không chứa bất kỳ heap block nào. Các Block nhập vào trong empty list sẽ tuân theo quy tắc first-in-last-out (FILO - vào trước thì ra sau). Empty table NO. 0 sẽ chứa các heap block có kích thước lớn hơn 1016 byte và nhỏ hơn 512 kbytes được sắp xếp theo thứ tự tăng dần kích thước. Dưới đây là hình ảnh mô tả empty table:

![Empty table index area](pic/pic3.PNG)

#### 2.2.3 Empty table bitmap
Kích thước của empty table bitmap là 128 bit, với mỗi bit tương ứng với một empty table tương ứng. Nếu không có bất kỳ free heap block nào trong empty table tương ứng, bit tương ứng trong empty table map sẽ là 0, ngược lại sẽ là 1. Sau khi cấp phát bộ nhớ từ empty table có kích thước tương ứng không thành công, hệ điều hành sẽ cố gắng tìm empty table gần nhất có kích thước đáp ứng kích thước cần cấp phát và có các free heap block từ empty table map. Điều này giúp tăng tốc độ của việc dùng empty table.

#### 2.2.4 Heap cache

Heap cache là một mảng chứa 896 pointers. Các con trỏ này là NULL để trỏ đến các free heap block có kích thước 1024-8192 bytes trong empty table NO. 0. Mỗi phần tử trong mảng tương ứng với một free heap block có kích thước `1024 bytes + 8 bytes * its index number` trong empty table NO. 0. Nếu có một free heap block trong empty table NO. 0 phù hơp với kích thước của nó, phần tử tương ứng trong mảng heap cache sẽ là một con trỏ trỏ đến free heap block đó, ngược lại phần tử tương ứng này sẽ là NULL. Phần tử cuối cùng là một phần tử đặc biệt, phần tử này không chỉ trỏ đến một free heap block có kích thước 8192 bytes (896*895) mà còn trỏ đến một free heap block có kích thước lơn hơn hoặc bằng 8192 bytes trong empty table NO. 0. Để tăng tốc độ truyên của heap cache, heap cache bitmap được giới thiệu để đánh dấu các con trỏ không phải NULL trong heap cache, có cơ chế tương tự như empty table bitmap. Sau khi sử dụng empty table bitmap để phân bổ bộ nhớ đến empty table khác 0, hệ thống sẽ cố gắn lấy index heap cache bitmap đến mảng heap cache để tìm free heap block trong empty table không đáp ứng kích thước phân bổ.

#### 2.2.5 Quick table
Fast table tương tự như Fastbin trong hệ thống Linux, nó là một cấu trúc dữ liệu tồn tại để đẩy nhanh việc phân phối các block nhỏ của hệ thỏ của hệ. Có 128 danh sách liên kết đơn trong quick table, mỗi danh sách liên kết đơn là một quick table. Trừ NO. 0 và NO. 1, các quick table từ NO. 2 đến NO. 127 sẽ duy trì từ 16 bytes (bao gồm cả header) đến 1016 bytes (bao gồm cả header) fast table với mỗi cái được tăng lên 8 bytes tức kích thước của mỗi fast table mà nó chứa sẽ là `fast table number * 8 bytes`. Vì heap header ở trạng thái nhàn rỗi (free) luôn là 8 byte nên fast table NO. 1 sẽ không chứa bất kỳ heap block nào. Mỗi fast table sẽ chứa tối đa 4 node, và cũng sẽ tuần thủ theo quy tắc FILO. Để cải thiện tốc độ phân bố của các heap block nhỏ, các free heap block trong fast table sẽ không được hợp lại. Cấu trúc của fast table được mô tả như hình dưới: 

![Fast table index area](pic/pic4.PNG)

### 2.3 Heap block operation
Trong memory, heap block được chia làm ba loại tùy thuộc vào kích thước của nó: small blocks (<1KB), large blocks (<512KB) và huge blocks (≥512KB). Chủ yếu có ba chế độ hoạt động cho các heap block: cấp phát heap block, giải phóng heap block, và hợp các heap block.

#### 2.3.1 Heap block allocation
Khi một heap block được cấp phát, nó chủ yếu được cấp phát từ fast table và empty table được đề cập ở trên.

Khi heap block được cấp phát từ fast table, trước tiên user sẽ đưa ra kích thước của heap block, dựa vào kích thước này, sẽ lấy ra chỉ mục (index) của fast table chứa kích thước tương ứng, free heap block cuối cùng được liên kết với bảng đó sẽ được lấy ra khỏi bảng và cấp phát cho user sử dụng. The header points to the free heap block of the next item.




