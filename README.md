Typical Heap Vulnerability in Windows System
-
Dịch từ bài báo: [Research on Generation Principle and Utilization Method of Typical Heap Vulnerability in Windows System](https://www.jianshu.com/p/a853040d2804)

Lưu ý bài dịch có thể không chính xác với nội dung mà tác giả truyền tải, làm ơn góp ý cho tôi nếu bạn thấy điều đó.

# ABSTRACT
Với sự tiến bộ của thời đại ngày nay cùng với sự phát triển khoa học và kĩ thuật, hiệu suất của máy tính cũng ngày càng phát triển (nhanh hơn, mạnh hơn), nhu cầu của mọi người đối với máy tính cá nhân cũng dần thay đổi, họ bắt đầu cần sự an toàn hơn là hiệu suất hoạt động. Đặc biệt, trong những năm gần đây, việc thường xuyên để lộ lỗ hổng bộ nhớ máy tính cá nhân đã gây nguy hiểm nghiêm trọng đến sự cố bảo mật thông tin cá nhân của người dùng, điều đó đã thúc đẩy quá trình chuyển hóa tư tưởng. Là hệ điều hành chủ đạo của máy tính cá nhân, hệ điều hành Windows gánh trên vai trọng trách chịu trách nhiệm về thông tin cá nhân của người dùng. Từ đó, bảo mật của hệ điều hành Windows liên quan trực tiếp đến bảo mật thông tin cá nhân của hầu hết mọi người.

Quản lí bộ nhớ stack trên Windows đã được nghiên cứu một cách triệt để, nó hoạt động riêng lẻ nên rất khó để có lỗ hỏng mới. Ngược lại với stack, heap có cơ chế quản lí và phương thức hoạt động tương đối phức tạp hơn.

Bài báo này sẽ khám phá lịch sử phát triển, thuật toán cơ bản, nguyên tắc hoạt động của heap trên hệ điều hành Windows và tóm tắt việc triển khai cụ thể cơ chế quản lý heap của hệ điều hành Windows tại mỗi giai đoạn mà nó tạo ra các nguyên tắc và phương pháp sử dụng của các lỗ hỏng heap điển hình. Mục tiêu là để hiểu sâu về điều cơ bản của hệ điều hành Windows thông qua giới thiệu và tóm lược, từ đó và cung cấp một số sự trợ giúp cho những người đam mê bảo mật quan tâm nhiều đến heap trên hệ điều hành Windows.

## 1. Research background
Trong những năm gần đây, lỗ hỏng trên hệ điều hành chủ đạo của máy tính cá nhân - Windows - đã lần lượt xuất hiện, đe dọa đến an toàn thông tin của người dùng. Trong đó lỗ hỏng quan trọng buffer overflow được xem là một lỗ hỏng kỳ cựu (veteran). Vì tò mò về nguyên nhân gây ra lỗ hỏng, tác giá đã bắt đầu khám phá về Windows heap buffer. Trong bộ nhớ của Windows,  là nơi bí ẩn nhất, hấp dẫn trong số các nơi hấp dẫn. Đồng thời, heap cũng là nơi đầy hỗn loạn của bộ nhớ Windows. vì Microsoft đã không tiết lộ đầy đủ các chi tiết về quản lý heap trong hệ điều hành Windows, tất cả chỉ có thể dựa vào các công cụ gỡ lỗi như `OllyDbg`, `WinDbg` và từ các tài liệu, bài viết được viết bởi các người đi trước để tiến bộ từ từ.

Hệ điều hành Windows đã trải qua nhiều năm phát triển, đi cùng với sự phát triển đó, cơ chế quản lí heap của Windows cũng đã trải qua những thay đổi lớn. Cơ chế quản lí heap hiện tại có tính đến nhiều yêu tố khác nhau chẳng hạn như việc sử dụng hiệu quả bộ nhớ của hệ điều hành Windows và hiệu quả của việc ra quyết định trong việc cấp phát/phân bổ bộ nhớ, an toàn và mạnh mẽ. Chính việc tối ưu hóa hiệu suất đã khiến cơ chế quản lí heap trên Windows trở nên cực kỳ phức tạp. Bài báo này sẽ lấy cơ chế quản lý heap trên nền tảng Win32 làm đại diện cho việc nghiên cứu sự phát triển của cơ chế quản lý heap trên hệ điều hành Windows. Từ việc nghiên cứu đó, tác giả bài báo đã chia việc nghiên cứu thành 3 giai đoạn:
  1. Windows 2000 - Windows XP SP1: Tại thời điểm này, hệ thống quản lý heap tương đối sơ khai. Nó không chú trọng đến sự an toàn của bộ nhớ heap, mà chú trọng vào việc phân bổ và cải thiện hiệu suất. Đây là giai đoạn mà vấn đề bảo mật của heap trở nên nghiêm trọng và dễ bị tấn công hơn.
  2. Windows XP SP2 - Windows 2003: Từ kinh nghiệm của giai đoạn trước, giai đoạn này, Windows chia trình quản lý heap thành hai trình quản lý khác nhau: front-end và back-end. Đồng thời họ cũng đã thêm vào nhiều biện pháp bảo vệ an toàn, ví dụ như header format của heap block được thay đổi và thêm vào một cơ chế security verification, cụ thể là cơ chế Cookie. Khi một node trong danh sách liên kết đôi được xóa, hệ thống sẽ xác minh pointer của heap block, điều này sẽ gây khó khăn hơn trong việc tấn công heap, tuy nhiên kẻ tấn công vẫn có thể sử dụng các phương thức tấn công nâng cao để khai thác thành công heap overflow vào các phần mêm chưa các code không được chuẩn hóa của lập trình viên.
  3. Windows Vista - Windows 7: Sau một thời gian dài phát triển, cơ chế quản lý front-end của heap đã được cải cách, một cơ chế quản lý heap và cấu trúc heap block mới đã được giới thiệu. Đây là một bước nhảy vọt trong hiệu quả phân phối và bảo vệ an toàn.
  
  Phẩn dưới đây sẽ giải thích chi tiết về việc chuẩn bị môi trường, cấu trúc quan trọng, cơ chế phân bổ, cơ chế bảo vệ của heap trong cả ba giai đoạn trên. Từ đó đưa ra nguyên nhân và phương pháp sử dụng các lỗ hỏng phổ biến.
  
## Windows 2000 - Windows XP SP1

### 2.1 Environmental preparation
Máy ảo Windows 2000 SP4 32-bit, OllyDbg, WinDbg.

### 2.2 Important structure
Ở giai đoạn này, toàn bộ heap space chủ yêu duy trì ở 4 structure: segment list, virtual allocation list, free list and lookaside. Trong đó, hai cấu trúc dữ liệu khác được liên kết đến một bảng trống, tên là Freelist Bitmap và Heap Cache. Sự ra đời của hai cấu trúc dữ liệu này giúp tăng tốc quá trình cấp phát qua việc giảm số lần sử dụng empty table trong quá trình cấp phát.

#### 2.2.1 Basic structure of heap
Cấu trúc heap của trạng thái bận trong giai đoạn này được biểu diễn như hình bên dưới:

![Heap block structure in occupied state](pic/pic1.PNG)

Ngược lại với hình trên, hình sau là cấu trúc heap ở trạng thái nhàn rỗi (free):

![Heap block structure in idle state](pic/pic2.PNG)

#### 2.2.2 Empty table
Trong quá trình cấp phát heap, chúng ta chủ yếu quan tâm đến các quy tắc phân bổ của empty tables và fast table, cái mà quản lý các heap block đã free. Tổng cộng có 128 danh sách liên kết đôi trong empty list. Mỗi danh sách liên kết đôi sẽ là một empty list. Trừ empty list NO. 0 và NO. 1, từ NO. 2 đến NO. 127 được duy trì từ 16 byte (bao gồm heap header) đến 1016 bytes (bao gồm heap header) với mỗi emply table sẽ tăng 8 bytes tức kích thước của mỗi heap block mà nó chứa sẽ là `empty table number * 8 bytes` (ví dụ NO. 10 sẽ chứa heap block có kích thước 10*8 = 80 bytes). Vì heap header ở trạng thái nhàn rỗi (free) luôn là 8 byte nên empty table NO. 1 sẽ không chứa bất kỳ heap block nào. Các Block nhập vào trong empty list sẽ tuân theo quy tắc first-in-last-out (FILO - vào trước thì ra sau). Empty table NO. 0 sẽ chứa các heap block có kích thước lớn hơn 1016 byte và nhỏ hơn 512 kbytes được sắp xếp theo thứ tự tăng dần kích thước. Dưới đây là hình ảnh mô tả empty table:

![Empty table index area](pic/pic3.PNG)

#### 2.2.3 Empty table bitmap
Kích thước của empty table bitmap là 128 bit, với mỗi bit tương ứng với một empty table tương ứng. Nếu không có bất kỳ free heap block nào trong empty table tương ứng, bit tương ứng trong empty table map sẽ là 0, ngược lại sẽ là 1. Sau khi cấp phát bộ nhớ từ empty table có kích thước tương ứng không thành công, hệ điều hành sẽ cố gắng tìm empty table gần nhất có kích thước đáp ứng kích thước cần cấp phát và có các free heap block từ empty table map. Điều này giúp tăng tốc độ của việc dùng empty table.

#### 2.2.4 Heap cache

Heap cache là một mảng chứa 896 pointers. Các con trỏ này là NULL để trỏ đến các free heap block có kích thước 1024-8192 bytes trong empty table NO. 0. Mỗi phần tử trong mảng tương ứng với một free heap block có kích thước `1024 bytes + 8 bytes * its index number` trong empty table NO. 0. Nếu có một free heap block trong empty table NO. 0 phù hơp với kích thước của nó, phần tử tương ứng trong mảng heap cache sẽ là một con trỏ trỏ đến free heap block đó, ngược lại phần tử tương ứng này sẽ là NULL. Phần tử cuối cùng là một phần tử đặc biệt, phần tử này không chỉ trỏ đến một free heap block có kích thước 8192 bytes (896*895) mà còn trỏ đến một free heap block có kích thước lơn hơn hoặc bằng 8192 bytes trong empty table NO. 0. Để tăng tốc độ truyên của heap cache, heap cache bitmap được giới thiệu để đánh dấu các con trỏ không phải NULL trong heap cache, có cơ chế tương tự như empty table bitmap. Sau khi sử dụng empty table bitmap để phân bổ bộ nhớ đến empty table khác 0, hệ thống sẽ cố gắn lấy index heap cache bitmap đến mảng heap cache để tìm free heap block trong empty table không đáp ứng kích thước phân bổ.

#### 2.2.5 Quick table
Fast table tương tự như Fastbin trong hệ thống Linux, nó là một cấu trúc dữ liệu tồn tại để đẩy nhanh việc phân phối các block nhỏ của hệ thỏ của hệ. Có 128 danh sách liên kết đơn trong quick table, mỗi danh sách liên kết đơn là một quick table. Trừ NO. 0 và NO. 1, các quick table từ NO. 2 đến NO. 127 sẽ duy trì từ 16 bytes (bao gồm cả header) đến 1016 bytes (bao gồm cả header) fast table với mỗi cái được tăng lên 8 bytes tức kích thước của mỗi fast table mà nó chứa sẽ là `fast table number * 8 bytes`. Vì heap header ở trạng thái nhàn rỗi (free) luôn là 8 byte nên fast table NO. 1 sẽ không chứa bất kỳ heap block nào. Mỗi fast table sẽ chứa tối đa 4 node, và cũng sẽ tuần thủ theo quy tắc FILO. Để cải thiện tốc độ phân bố của các heap block nhỏ, các free heap block trong fast table sẽ không được hợp lại. Cấu trúc của fast table được mô tả như hình dưới: 

![Fast table index area](pic/pic4.PNG)

### 2.3 Heap block operation
Trong memory, heap block được chia làm ba loại tùy thuộc vào kích thước của nó: small blocks (<1KB), large blocks (<512KB) và huge blocks (≥512KB). Chủ yếu có ba chế độ hoạt động cho các heap block: cấp phát heap block, giải phóng heap block, và hợp các heap block.

#### 2.3.1 Heap block allocation
Khi một heap block được cấp phát, nó chủ yếu được cấp phát từ fast table và empty table được đề cập ở trên.

Khi heap block được cấp phát từ fast table, trước tiên user sẽ đưa ra kích thước của heap block, dựa vào kích thước này, sẽ lấy ra chỉ mục (index) của fast table chứa kích thước tương ứng, free heap block cuối cùng được liên kết với bảng đó sẽ được lấy ra khỏi bảng và cấp phát cho user sử dụng. Header sẽ trỏ đến free heap block của item tiếp theo.

Khi thực hiện cấp phát heap block từ một empty table, một empty table có kích thước tương ứng sẽ được lấy ra đầu tiên, free heap block cuối cùng liên kết với bảng đó sẽ được lấy ra khỏi bảng được cáp phát cho user sử dụng, con trỏ item cuối cùng của empty table header sẽ được trỏ đến vị trí tiếp theo của item bị lấy ra. Nếu cấp phát thất bại đối với empty table có kích thước tương ứng, nó sẽ đi tìm item tối ưu phụ trong empty table tiếp theo để cấp phát cho đến khi nó tìm thấy free heap block có kích thước nhỏ nhất có thể thỏa mãn việc cấp phát bộ nhớ. Khi tìm thấy item tối ưu phụ trong empty list, nó sẽ lấy ra kích thước tương ứng của item đó và cấp phát, tức là nó sẽ lấy ra một heap block có kích thước tương ứng kích thước cần cấp phát từ một heap block lớn hơn (item được tìm thấy) và cấp phát cho chương trình, phần còn lại sẽ được tạo thành một heap block và thêm vào empty list tương ứng với kích thước. Trong trường hợp tất cả empty table (trừ NO. 0) đều duyệt và phân bổ không thành công, nó sẽ xet kích thước của heap block cuối cùng trong NO. 0 empty table có lớn hơn kích thước của bộ cần được cấp phát bộ nhớ không. Nếu lớn hơn, nó sẽ đi từ heap block cuối cùng đến heap block đầu tiên để tìm kiếm một heap block có kích thước nhỏ nhất tương ứng với kích thước cần được cấp phát.

Khi người dùng đăng ký cấp phát một bộ nhớ có kích thước nhất định, trước tiên hệ thống sẽ xác định xem heap block được yêu cầu có thuộc loại huge blocks. Nếu nó là huge block, nó sẽ sử dụng virtual allocation (cái này ít gặp hơn trong việc khai thác lỗ hỏng nên sẽ không đề cập ở đây). Nếu nó là một large blocks, heap cache đầu tiên sẽ được xem xét để cấp phát. Nếu cấp phát không thành công, nó sẽ tìm heap block phù hợp nhất từ NO. 0 empty table. Nếu người dùng đăng ký một small blocks, đầu tiên nó sẽ kiểm tra có heap block nào trong fast table có kích thước tương ứng không, nếu không, nó sẽ kiểm tra xem có heap block nào trong empty table có kích thước tương ứng hay không, nếu vẫn không, nó sẽ tìm bất kỳ heap block nào trong empty table để lấy ra heap block tương ứng và cấp phát thông qua empty table bitmap. nếu vẫn tiếp tục không tìm thấy, nó sẽ sử dụng heap cache, nếu việc cấp phát thất bại, nó sẽ tìm một free block phù hợp trong empty table để cấp phát, nếu vẫn thất bại, nó sẽ thực hiện cấp phát lại sau khi bộ nhớ được nén.

#### 2.3.2 heap block release
Heap block được giải phóng sẽ thay đổi từ trạng thái occupied sang trạng thái free. Khi giải phóng một vùng nhớ có kích thước nhất định, trước tiên nó sẽ xem xét heap block đó có phải loại huge blocks. Nếu nó là huge blocks, vùng nhớ đó sẽ được giải phóng trực tiếp mà không cần nhập bất cứ gì vào heap table. Nếu nó là large heap, nó sẽ cố gắng giải phóng vào heap cache. Nếu heap cache đầy, nó sẽ được liên kết với NO. 0 empty table. Nếu nó là small blocks, trước tiên nó sẽ cố gắng liên kết vào trong fast table có kích thước tương ứng, nếu liên kết vào fast table, để quá trình phân bổ các khối heap diễn ra nhanh, hệ điều hành sẽ không thay đổi trạng thái occupied của nó. Nếu trong fast table có kích thước tương ứng đã có đủ 4 heap block liên kết với nhau, heap block giải phóng đó sẽ được liên kết với empty table có kích thước tương ứng.

#### 2.3.3 Heap block merge
Khi heap block được giải phóng, nếu nó nằm trong empty table (free heap block nằm trong fast table sẽ không được hợp lại) và có heap block liền kề với địa chỉ vật lý của nó ở trạng thái free, hai khối heap đó sẽ được hợp lại. Khi hợp các heap block lại, heap block sẽ được lấy ra khỏi empty table, hai vùng nhớ liền kề được hợp nhất và tạo ra một free heap block mới với một header mới, sau đó nó sẽ được liên kết đến một empty table có kích thước tương ứng với kích thước của free heap block mới. Ngoài ra, việc cấp phát heap block sẽ kích hoạt việc hợp nhất các heap block, nếu cấp phát tại các vùng fast table, heap cache, empty table không thành công, nó sẽ kích hoạt nén bộ nhớ. Bộ nhớ sau khi nén sẽ hợp nhất tất cả các free heap block trong không gian heap (bất kể các địa chỉ có liên tục với nhau hay không) thành một large free heap block và cấp phát ngay sau đó.

### 2.4 Protection mechanism
Cơ chế bảo vệ bộ nhớ của Microsoft cho hệ điều hành Windows là khá ít cho đến phiên bản Windows XP SP2. Tại giai đoạn Windows 2000 - Windows XP SP1. Microsoft chỉ chú trọng vào hiệu suất và hoàn thiện chức năng của hệ điều hành, dành quá ít cho việc bảo mật. Chính vì vậy mà lỗ hỏng ở giai đoạn này khá nhiều và dễ khai thác.

### 2.5 Exploit
Như đã nói ở trên, giai đoạn này là giai đoạn đầu của hệ điều hành Windows, nên chỉ chú trọng vào hiệu suất và hoàn thiện chức năng cho hệ điều hành, không xem xét nhiều đến các yêu tố bảo mật. Vì thế, các phương thức tấn công heap trong giai đoạn này là đa dạng nhất: free and stable, such as DWORD SHOOT, Heap Spray,... Tiếp theo sẽ là phần nói về các nguyên nhân và phương thức khai thác của các lỗ hổng cổ điển và phổ biến của hệ điều hành ở giai đoạn này.

#### 2.5.1 DWORD SHOOT
##### 2.5.1.1 Causes of Vulnerability
Nguyên nhân chính gây ra lỗ hỏng này là khi empty table thực hiện hủy liên kết đến heap block, con trỏ front pointer và next pointer của heap block không được kiểm tra an toàn việc sinh ra các kẻ hở trong việc gán giá trị. Dưới đây là mã giả của hàm hủy liên kết.
``` c
void Unlink (listNode *node) {
  node->Blink->Flink = node->Flink;
  node->Flink->Blink = node->Blink;
}
```

Kẻ tấn công sẽ đạt được được ý định bằng cách ghi đè vào 4 bytes dữ liệu bằng một địa chỉ bất kỳ, chính vì vậy mà nó có tên là DWORD SHOOT. Để ngăn những kẻ tấn công sử dụng phương thức này, Windows đã cập nhật một cơ chế Safe Unlink ở phiên bản tiếp theo để kiểm tra tính hợp lệ của con trỏ trước và con trỏ sau của Unlink heap block.

##### 2.5.1.2 How to use
Cơ bản dựa vào heap overflow, sủa đổi previous pointer và next pointer trong header của heap block liền kề, sau đó unlink heap block đã sửa đổi, hai con trỏ previous pointer và next pointer sẽ không bị phát hiện tính hợp lệ do lỗ hỏng của thuật toán Unlink, Flink data sẽ ghi vào vị trí  tại bất kỳ địa chỉ nào mà Blink được sửa đổi. Ta có thể thay đổi thành địa chỉ của một hàm hay của một virtual table của một hàm khác, sau đó hướng chương trình nhảy đến địa chỉ mà ta mong muốn và thực hiện cái ta muốn (ví dụ như shellcode).

Rõ ràng việc thực thi phương pháp này với một đoạn code độc hại bằng cách giả mạo địa chỉ hàm trong PEB trỏ đến một địa chỉ bắt đầu của shellcode. Có rất nhiều hàm được lưu trong cấu trúc của PEB, RtlEnterCriticalSection() và RtlLeaveCriticalSection() được đề xuất vì khi chương trình kết thúc, hàm ExitProcess() được gọi, để đồng bộ hóa các thread, chương trình sẽ gọi RtlEnterCriticalSection() và RtlLeaveCriticalSection(). Ngoài ra trong giai này, địa chỉ PEB trên windows được cố định ở 0x7FFDF000, con trỏ hàm RtlEnterCriticalSection() ở offset 0x20 nên địa chỉ của nó là 0x7FFDF020, địa chỉ ngay sau nó 0x7FFDF020 là con trỏ hàm RtlLeaveCriticalSection(). Từ những ví dụ trên, ta thấy được cấu trúc PEB của hệ điều hành windows ở giai đoạn này là một điểm tấn công tuyệt vời cho lỗ hỏng ghi địa chỉ bất kỳ như DWORD SHOOT. Để khắc phục điều này, Microsoft đã cập nhật cơ chế random PEB cho giai đoạn tiếp theo thông qua việc ngẫu nhiên hóa địa chỉ của cấu trúc PEB.

Ngoài tấn công cấu trúc PEB, lỗ hổng này thường tấn công cấu trúc SEH, cấu trúc VEH, cấu trúc UEF, ... trong cơ chế xử lý ngoại lệ của Windows. Vì các cấu trúc trên đều có địa chỉ cố định trong bộ nhớ nên cách sử dụng cũng giống như cấu trúc PEB vừa đề cập, vì vậy ta sẽ không nói đến các bước thực hiện tấn công các câu trúc này.

#### 2.5.2 Heap Spray
##### 2.5.2.1 Causes of Vulnerability
Khác với các lỗ hỏng có thể thực hiện tấn công một cách chính xác, Heap Spray là một phương thức tấn công tương đối mạnh mẽ, và thường được sử dụng cho các trình duyệt, bởi các chương trình này không có quá nhiều ràng buộc khi phân bổ trên heap, vì thế kẻ tấn công sẽ tạo ra nhiều các heap block để chiếm phần lớn bộ nhớ trên heap, khi đã phủ hết toàn bộ không gian heap, kẻ tấn công chiến luồng điều khiển chương trình mà tiêm đoạn mã độc hại vào để thực thi.

Khi sử dụng stack overflow, sau khi chiếm được luồng điều khiển chương trình, EIP thường được sửa đổi để trỏ đến shell code đã đặt sẵn trên stack, để tăng xác suất thực thi thành công shellcode, một đoạn mã nhỏ không ảnh hưởng đến shellcode được thêm vào phần đầu shellcode, các lệnh này thường là `nop` (0x90) và `or al` (0x0c0c), gọi chung là lệnh [`slide` hoặc `sled`](https://en.wikipedia.org/wiki/NOP_slide). Với sự cải thiện của bảo mật trên hệ điều hành, đặc biệt là cơ chế ngẫu nhiên hóa được sinh ra, rất khó để các kiểu tấn công thông thường có thể thực hiện được. Vì vậy mà các nhà nghiên cứu đã phát minh ra một phương thức spraying như một phương thức phụ trợ trong tấn công.

##### 2.5.2.2 How to use
Điều kiện tiên quyết của kiểu tấn công này là giá trị EIP có thể sửa đổi thành 0x0c0c0c0c hay không. Mỗi khi đăng ký 1M không gian bộ nhớ, ta sẽ sử dụng nhiều lệnh 0x0c cùng với shellcode để lắp đầy vùng nhớ đó. Nói chung, shellcode chỉ chiếm khoảng vài chục byte, các lệnh `slide` sẽ chiếm tương đối gần 1M, do đó kích thước của các lệnh `slide` sẽ lớn hơn nhiều so với shellcode. Thực hiên việc đăng ký vùng heap 1M này nhiều lần và tạo dữ liệu như trên, đến một lúc nào đó địa chỉ heap 0x0c0c0c0c cũng sẽ chứa các lệnh `slide` và shellcode, do lệnh `slide` chiếm đa số trong 1M ấy nên có đến hơn 99% là 0x0c0c0c0c sẽ chứa lệnh `slide` 0x0c và sau một loạt lệnh này sẽ là shellcode. Nhờ vào việc phân bổ địa chỉ heap từ thấp đến cao, thông thường 1 heap block sẽ có kích thước 200M (0x0c800000) bao phủ cả địa chỉ 0x0c0c0c0c, hình dưới sẽ cho ta cái nhìn cụ thể hơn về heap spray:

![](pic/pic5.PNG)

Lệnh `slide` 0x90 (NOP) không được sử dụng ở đây bởi vì các con trỏ virtual function của nhiều đối tượng được lưu trữ trong không gian bộ nhớ. Khi có một virtual function bị ghi đè thành 0x90909090, việc gọi hàm này sẽ làm chương trình bị crash. Hệ điều hành cấp phát cho người dùng một vùng nhớ 2G đầu tiền, nghĩa là từ 0x00000000 - 0x7FFFFFFF, trong đó tiến trình chỉ có thể truy cập vào vùng nhớ 0x00010000 - 0x7FFEFFFF, vùng nhớ 2G cuối (0x80000000 - 0xFFFFFFFF) được thiết kế chỉ để cho kernel truy cập vào. Việc ghi đè địa chỉ 0x0c0c0c0c vẫn thuộc vùng bộ nhớ mà tiến trình của người dùng có thể truy cập vào, ngược lại nếu ghi đè 0x90909090, vùng nhớ này nằm trên vùng nhớ của kernel, tiến trình không được phép truy cập vào sẽ dẫn đến crash.

## 3. Windows XP SP2-Windows 2003
### 3.1 Environmental preparation
32-bit Windows XP SP3 virtual machine, OllyDbg, WinDbg.

### 3.2 Important structure
Ở giai đoạn này, cấu trúc dữ liệu của heap block cơ bản được kế thừa từ cấu trúc dữ liệu của giai đoạn trước (Windows 2000 - Windows XP SP1). Tuy nhiên, các header sẽ được bộ sung các phương thức bảo vệ, vì vậy mà chúng có một số điểm khác so với cấu trúc ban đầu.

Dưới đây là cấu trúc của một heap block ở trạng thái bận:

![Heap block structure in occupied state](pic/pic6.PNG)

Dưới đây là cấu trúc của một heap block ở trạng thái nhàn rỗi:

![Heap block structure in idle state](pic/pic7.PNG)

### 3.3 heap block operation
Tại giai đoạn này, Heap allocation được chia thành trình quản lý heap front-end (Front-End Manager) và trình quản lý back-end (Back-End Manager). Trong đó, Front-end Manager chủ yếu thực hiện phân bổ fast table, Back-End Manager gồm các cơ chế phân bổ liên quan đến empty table. Ngoài hai trình quản lý heap trên, các hoạt động như cấp phát, giải phóng và hợp nhất heap block được kế thừa từ hoạt động của heap block trong giai đoạn trước ((Windows 2000 - Windows XP SP1).

### 3.4 Protection mechanism
Từ giai đoạn này, Microsoft đã bắt đầu chú ý đến việc bảo mật trên hệ điều hành Windows, họ đã thêm từ từ các cơ chế bảo mật vào hệ thống như: GS, Safe SEH, DEP, ASLR,... và một số cơ chế bảo vệ heap khác. Trong phần này, tác giả sẽ giải thích các cơ chế bảo vệ heap mới được thêm vào.

#### 3.4.1 Heap Cookie
Heap Cookie được sử dụng từ phiên bản Windows XP SP2, nó thay đổi cơ chế bảo vệ của Windows heap block thành cơ cấu trúc được đề cập ở trên, nó sẽ thay thế 1-byte của segment index trong thông tin của heap header thành cookie được sử dụng để xác minh xem có diễn ra heap overflow hay không, nó cũng thay thế 1-byte tương ứng củng Tag index thành segment index, loại bỏ hoàn toàn tag index.

Cơ chế tạo ngẫu nhiên 1-byte cookie random trong header khi heap block được phân bổ nhằm bảo vệ các vị trí khác trong header: flag, unused bytes, segment index và previous heap block pointer (Flink), dữ liệu của next heap block pointer (Blink) sẽ không thể thay đổi bằng heap overflow. Sau khi heap được giải phóng, nó sẽ kiểm tra xem cookie trong heap header có bị giả mạo hay không, nếu bị giả mạo, hàm RtlpHeapReportCorruption() sẽ được gọi và tiến trình sẽ kết thúc. Điều đáng nói là hàm này chỉ kết thúc tiến trình chỉ sau khi trường HeapEnableTerminateOnCorrupton được thiết lập, tuy nhiên trường này lại không được bật mặc định trong phiên bản của các hệ điều hành trong giai đoạn này dẫn đến việc hàm này không thể đóng tiến trình :).

#### 3.4.2 Safe Unlink
Cơ chế này là một cơ chế được thêm vào dùng để kiểm tra an toàn trước khi thực hiện thuật toán Unlink của giai đoạn trước. Cơ chế này sẽ kiểm tra tính hợp lệ của front pointer và next pointer của heap header khi heap block được xóa khói heap table, nhằm giải quyết vấn đề về việc 2 con trỏ trên có thể bị giả mạo ở phiên bản trước. Dưới đây là một đoạn mã giả được viết bằng code C của cơ chế này:
``` c
// Safe Unlink algorithm
void Safe_Unlink(ListNode *node) {
  if ((node->Blink->Flink == node) && (node->Flink->Blink == node) {
    node->Blink->Flink = node->Flink;
    node->Flink->Blink = node->Blink;
  }
  else {
    ReportHeapCorruption(node);
  }
}
```

#### 3.4.3 PEB Random
Cấu trúc PEB (Process Envirorment Block Structure) chưa thông tin của tiến trình, bằng cơ chế ngẫu nhiên hóa địa chỉ của cấu trúc PEB thay cho địa chỉ cố định (0x7FFDF000) ở phiên bản trước, nó đã giải quyết được mối nguy hại về bảo mật khi thực thi code độc hại thông qua việc thay đổi con trỏ hàm có địa chỉ cố định trong cấu trúc PEB của giai đoạn trước.

### 3.5 Exploit
Như đề cập ở trên, giai đoạn này chỉ thêm vào các cơ chế bảo mật để khắc phục các lỗi xảy ra ở giai đoạn trước, điều này dường như chỉ tập trung khắc phục lỗi ở empty table, do đó các nhà nghiên cứu bảo mật đã tập trung tìm lô hỏng trên fast tables, empty tables No. 0, heap buffers, và empty table bitmaps.

#### 3.5.1 Bypass Safe Unlink
##### 3.5.1.1 Causes of vulnerabilities
Mặc dù việc thêm vào Safe Unlink đã hạn chế các cuộc tấn công sử dụng DWORD SHOOT, các nhà nghiên cứu đã nghiên cứu về cơ chế phát hiện Safe Unlink, một kịch bản rất khắc khe đã được xây dựng để bypass Safe Unlink, họ phát hiện cơ chế này có một lỗ hỏng dẫn đến việc có thể ghi một địa chỉ tùy ý vào.

##### 3.5.1.2 How to use
Theo cơ chế bảo vệ Safe Unlink được đề cập ở trên, khi unlinking một heap block, nó sẽ kiểm tra liệu trường Flink của heap block tiếp theo nó và trường Blink của heap block phía trước nó có trỏ đến nó hay không. Hai con trỏ này cách nhau 4 byte, vì vậy ta có thể hiểu đoạn code kiểm tra điều kiện ở trên có thể thay bằng đoạn code sau:
``` c
if ((node->Blink == node) && (node->Flink + 4 == node))
```

Khi heap block cần được hủy liên kết là heap block duy nhất trên empty table, sẽ có một trường hợp đặt biệt diễn ra: trường Flink và Blink của heap block đó giống nhau đều trỏ đến empty header node và trường Flink và Blink của empty header node cũng bằng nhau và trỏ đến heap block đó, xem hình bên dưới sẽ rõ hơn:

![Bypass Safe Unlink (1)](pic/pic8.PNG)

Nếu có thể sửa đổi trường Flink của heap block đó đến Freelist[x-1].Blink thông qua lỗ hỏng heap overflow và sửa đổi trường Blink thành Freelist[x].Blink, ta vẫn sẽ bypass được Safe Unlink, xem hình dưới để có cái nhìn rõ hơn:

![Bypass Safe Unlink (2)](pic/pic9.PNG)

Sau khi bypass được Safe Unlink, hệ thống sẽ thực hiện Unlink bình thường và kết quả sẽ như hình sau:

![Bypass Safe Unlink (3)](pic/pic10.PNG)

Nếu ta tạo ra một heap block có kích thước tương đương với Freelist[x], Heap block được trỏ bởi Freelist[x] sẽ được cấp phát theo thuật toán được xây dựng trước đó. Như vậy Freelist[x-1].Blink và vùng nhớ bên dưới nó sẽ được cấp phát và xem như là một heap block, vùng dữ liệu mà người dùng nhập vào sẽ từ Freelist[x], do đó ta có thể ghi đè Freelist[x].Blink thành bất kỳ địa chỉ nào mà ta muốn, từ đó ta tiếp tục ghi đè dữ liệu vào địa chỉ ta đã tạo.

#### 3.5.2 LookAside Attack
##### 3.5.2.1 Causes of Vulnerability
Lỗ hỏng này được tạo ra khi fast table phân bổ một heap block, tính hợp pháp của địa chỉ được trỏ bởi trường Flink không được kiểm tra, điều này khiến cho người dùng có thể gán một địa chỉ giả mạo vào heap header khi fast table thực hiện thuật toán phân bổ bộ nhớ, tùy đó dẫn đến lỗ hỏng ghi dữ liệu bất kỳ vào địa chỉ bất kỳ.

##### 3.5.2.2 How to use
Dựa vào heap overflow, do fast table chỉ sử dụng danh sách liên kết đổi (chỉ dùng Flink), nên ta sử dụng heap overflow để sửa đổi previous pointer của heap block được liên kết với empty table để nhảy đến địa chỉ hàm hoặc địa chỉ của virtual table, sau đó xây dụng một heap block giả tại địa chỉ ấy. Khi fast table phân bổ một heap block ở lần đầu tiên có kích thước tương ứng, heap header được làm giả sẽ được phân bổ cho người dùng sử dụng, và địa chỉ Flink không hơp lệ sẽ được liên kết với một empty header node như là một heap header. Khi fast table phân bổ một heap block ở lần thứ hai có kích thước tương ứng, địa chỉ đặc biệt và vùng nhớ đằng sau nó sẽ được xem là một heap block cấp phát cho user, từ đó user có thể ghi đè bất kỳ dữ liệu nào vào địa chỉ này. Các địa chỉ đặc biệt này có thể là địa chỉ của các hàm hay địa chỉ của virtual table cũng như các địa chỉ bị ảnh hưởng trong các cuộc tấn công heap được đề cập ở trên như cấu trúc PEB và các cấu trúc xử lý ngoại lệ khác nhau. Xem hình bên dưới để hiểu rõ hơn về cách hoạt động: 

![LookAside Attack utilization process](pic/pic11.PNG)

#### 3.5.3 Bitmap XOR Attack
##### 3.5.3.1 Causes of vulnerabilities
Lỗ hổng này xảy ra khi trạng thái của empty table bitmap được cập nhật, nó sử dụng trường Size của heap block để làm index mà không kiểm tra tính hợp lệ, điều này khiến trạng thái của empty table bitmap khác với trạng thái của empty table. Cuối cùng nó cũng sẽ gây lỗ hỏng khiến người dùng có thể ghi dữ liệu tùy ý vào địa chỉ bất kỳ. Dưới đây là mã giả của thuật toán cập nhật empty table bitmap:
``` c
// Safe Unlink
next = vent->Flink;
prev = vent->Blink;
if ((prev->Flink != next->Blink) || (prev->Flink != listhead)) {
  RtlpHeapReportCorruption(vent);
}
else {
  prev->Flink = next;
  next->Blink = prev;
}

// Update Bitmap
if (next == prev) {
  vSize = vent->Size;
  vHeap->FreeListsInUseBitmap[vSize >> 3] ^= 1 << (vSize & 7);
}
```

##### 3.5.3.2 Usage
Như thuật toán được biểu diên bằng mã giả ở trên, sau khi mỗi heap block trong bảng empty table được hủy liên kêt, nó sẽ xem xét xem empty table bitmap tương ứng có cần được cập nhật lại. Nếu heap block bị hủy liên kết là heap block cuối cùng trong bảng empty table, empty table bitmap tương ứng với trường size sẽ được xor. Dựa trên kịch bản heap overflow sẽ thấy được nhiều lỗ hỏng trong thuật toán này.

Đầu tiền tạo một empty table chỉ có một heap block và có xảy ra heap overflow heap liền kề trước nó như hình bên dưới:

![Bitmap XOR Attack(1)](pic/pic12.PNG)

nếu có thể overflow single-byte phía trên heapblock, nó có thể ghi vào trường size của heap block trong empty table. Trước khi thực hiện hoạt động Unlink heap block trong empty table, đầu tiên nó sẽ thay đổi trường size thành n*8 như hình bên dưới:

![Bitmap XOR Attack(2)](pic/pic13.PNG)

Theo thuật toán cập nhật của empty table bitmap. heap block sẽ thực hiện hoạt động hủy liên kết như bình thường, sau đó đoạn code để cập nhật empty table bitmap sẽ được thực thi. Tuy nhiên, trường size lúc này đã bị ghi đè, nó không thay đổi index theo bitmap[x] mà theo bitmap[n], từ đó xor index đó trong empty table bitmap dẫn đến bitmap[x] không thay đổi, còn bitmap[n] thì bị đảo ngược lại (từ 0 thành 1 hoặc từ 1 thành 0). 

![Bitmap XOR Attack(3)](pic/pic14.PNG)

Tại thời điểm này, không có bất kỳ heap block nào trong empty table x, previous pointer và next pointer của header sẽ trỏ đến chính nó (hình trên). Và empty table bitmap tương ứng với nó (bitmap[x]) sẽ có giá trị là 1, lúc này, khi nhìn bào empty table bitmap, trình quản lý heap sẽ nghĩ rằng vẫn có một free heap block nằm ở empty table x. Nếu user đăng ký một vùng nhớ có kích thước là 8 * x, trình quản lý sẽ xem vùng nhớ từ freelist[x].Flink trở xuống là một heap block và sẽ cấp phát cho người dùng, từ đó, người dùng có thể ghi dữ liệu bất kỳ vào địa chỉ bất kỳ.

Kịch bản được bàn luận ở trên xảy ra khi heap overflow chỉ đè vào bit size của header. Khi heap overflow có thể ghi đè trường con trỏ của item trước và sau heap block, ta có thể mở rộng kịch bản này bằng nhiều kỹ thuật tấn công khác.

Kịch bản đầu tiên là ghi đè previous pointer và the next pointer thành cùng một giá trị. Tại thời điểm này, theo thuật toán update của empty table bitmap,  cơ chế phát hiện an toàn của Safe Unlink sẽ kiểm tra và hoạt động hủy liên kết sẽ không được thực hiện trên heap block đó. Hàm RtlpHeapReportCorruption() được gọi, như đề cập ở trên, hàm này sẽ không dừng tiến trình trong phiên bản này. Do đó 2 con trỏ prev và next không thay đổi sau khi được kiểm tra. Lúc này hệ thống sẽ tiến hành cập nhật empty table bit map, trường size lúc này đã được thay đổi bằng heap overflow, các bước tiếp theo sẽ được thực hiện như trên.

Kịch bản thứ hai được xây dựng để việc hủy liên kết được bỏ qua thông qua việc gán con trỏ prev và next luôn bằng nhau. và empty table bitmap phải được cập nhật. Do đó nó không cần heap block bị overflow phải là heap block nằm trong empty list, điều này giúp cho việc ứng dụng kịch bản trên trở nên mở rộng và đa dạng hơn.

#### 3.5.4 Freelist[0] Linking Attack
##### 3.5.4.1 Causes of vulnerabilities
Sau khi giới thiệu cơ chế Saft Unlink làm cho việc hủy liên kết trở nên khó khăn hơn, các nhà nghiên cứu chuyển sự chú ý sang tiến trình liên kết ngược của việc hủy liên kết. Họ đã sớm phát hiện rằng hoạt động liên kết đã không có các cơ chế bảo vệ giúp phát hiện tính hợp lệ của prev pointer và next pointer của heap block và có thể làm tương tự như lỗ hỏng DWORD SHOOT thông qua việc gán con trỏ. Tuy nhiên, họ thấy rằng nó có một hạn chế so với DWORD SHOOT, nó chỉ có thể ghi 4 byte địa chỉ heap block thành một địa chỉ bất kỳ. Dưới đây là đoạn mã giả của thuật toán liên kết, trong đó chunk A là một heap block sẽ được liên kết với empty table NO. 0, chunk B là một heap block nằm trong empty table NO. 0.
``` c
// Link algorithm
ChunkA->Flink = ChunkB->Flink;
ChunkA->Blink = ChunkB->Blink;
ChunkB->Blink->Flink = ChunkA;
ChunkB->Flink->Blink = ChunkA;
```

##### 3.5.4.2 Usage
Đầu tiên xây dựng một kịch bảng ghi đè ít nhát 0x10 bytes vào prev block của block liền kề trong freelist[0], kích thước của block phía sau nó nên lớn hơn 2 lần kích thước của nó, ở đây là 0x220 * 2 < 0x550 byte như hình bên dưới:

![Freelist[0] Linking Attack(1)](pic/pic15.PNG)

Trước khi đăng ký một heap block từ empty list 0, ta sẽ overflow heap header của heap block đó trong empty list, ghi đè 2 con trỏ prev và next, không cần thay đổi trường size như hình sau:

![Freelist[0] Linking Attack(2)](pic/pic16.PNG)

Lúc này, ta đăng ký một heap block có kích thước nằm ở giữa kích thước của 2 heap block đó trong empty list, như ở đây ta sẽ đăng ký kích thước là 0x250 vì 0x220 < 0x250 < 0x550 và 0x550 - 0x250 > 0x250. Theo thuật toán phân bổ heap của NO. 0 empty table, heap block có kích thước 0x550 sẽ được hủy liên kết đầu tiên. Con trỏ prev và next của block này đã bị thay đổi, do đó nó sẽ không pass cơ chế kiểm tra Safe Unlink, việc hủy liên kết sẽ không được thực hiện và heap block đó sẽ được chia thành 2 heap block 0x250 và 0x300, heap block 0x250 sẽ được cấp phát cho người dùng, còn heap block 0x300 sẽ được chèn vào vị trí thích hợp trong empty table NO. 0 theo thuật toán, và chắc chắn nó sẽ nằm sau heap block 0x250 (0x250 < 0x300 < 0x550):

![Freelist[0] Linking Attack(3)](pic/pic17.PNG)

Trước khi thực hiện việc Link heap block này tại một vị trí thích hợp, nó sẽ xét trường size của Flink_Fake và Blink_Fake (hiểu đơn giản là xét kích thước 2 heap block trước và sau nó) có lớn hơn heap block cần được chèn vào hay không, trong kịch bản này [Fake_Flink-8]>0x300 và [Fake_Blink-0xc]0x300. Ngoài ra các điều kiện cần được thỏa mãn và địa chỉ của Fake_Flink và Fake_Blink+4 có thể được ghi.

Sau khi thỏa mãn các điều kiện ở trên, heap block 0x300 sẽ được chèn vào vị trí thích hợp trong NO. 0 empty table, lỗ hỏng thuật toán Link sẽ được được biểu diễn như sau:
``` c
// Trigger effect
0x300Chunk->Flink = Fake_Flink;
0x300Chunk->Blink = Fake_Blink;
[Fake_Flink] = 0x300Chunk;
[Fake_Blink + 4] = 0x300Chunk;
```

Vì trường Fake_Flink và Fake_Blink có thể kiểm soát được thông qua heap overflow, ta có thể ghi đè địa chỉ của heap  block thành địa chỉ bất kỳ. Mặc dù nó khá là khó để chiếm được quyền điều khiển, ta vẫn có thể phối hợp cùng các lỗ hỏng khác để thực hiện exploit.

#### 3.5.5 Freelist[0] Searching Attack
##### 3.5.5.1 Causes of vulnerabilities
Lỗ hỏng tạo ra khi duyệt NO. 0 empty table để tìm ra một heap block thích hợp, tính hợp lệ của con trỏ của heap block trong danh sách liên kết không được xác thực khiến NO. 0 empty table jump out khi đang duyệt, gây ra lỗ hổng khiến ta có thể ghi đè bất kỳ vào địa chỉ bất kỳ.

##### 3.5.5.2 Usage
Đầu tiên xây dựng kịch bản sao cho ghi đè được ít nhất 0xc bytes vào prev pointer của heap block liền kề với trong Freelist[0], lưu ý heap block này không phải là heap block có kích thước lớn nhất trong NO. 0 empty table.

![Freelist[0] Searching Attack(1)](pic/pic18.PNG)

Trước khi bắt đầu, ta sẽ tiền hành sử dụng heap overflow để ghi đè vào prev pointer, trong kịch bản này, ta không cần phải ghi đè trường size.

![Freelist[0] Searching Attack(2)](pic/pic19.PNG)

Lúc này, tiến hành đăng ký một vùng nhớ có kích thước lớn hơn kích thước heap block bị overflow và nhỏ hơn kích thước của heap block lớn nhất trong NO. 0 empty table. Theo thuật toàn tìm kiếm của NO. 0 empty table, khi đang duyệt heap block bị overflow, Fake_Link giả sẽ được sử dụng như một địa chỉ chứa heap block tiếp theo, và trường size sẽ được so sánh xem có đáp ứng được vùng nhớ chương trình yêu cầu không, 

![Freelist[0] Searching Attack(3)](pic/pic20.PNG)

Để trình quản lý heap xem địa chỉ Fake_Flink như một heap block để cấp phát cho user, nó cần thỏa mãn rằng trường size của [Fake_Flink-8] phải lớn hơn kích thước chương trình yêu cầu. Để không xảy ra việc phân một heap block thành hai heap block nhỏ, trường size nên được kiểm soát nhỏ hơn kích thước chương trình yêu cầu + 8 byte (RequestSize < SizeField < RequestSize + 8). Sau khi thỏa điều kiện, heap block giả sẽ được Unlink. Tuy nhiên nó sẽ bị phát hiện bởi cơ chế Safe Unlink, để nó vẫn sẽ được cấp phát cho người dùng, ta cần giả mạo Fake_Flink và Fake_Flink + 4 (Flink và Bilnk) thành một vùng hợp lệ thỏa Safe Unlink.

## 4. Windows Vista-Windows 7
### 4.1 Environmental preparation
32-bit Windows 7 SP1 virtual machine, OllyDbg, WinDbg.

### 4.2 Important structure
Bắt đầu từ Windows Vista, hệ điều hành Windows đã loại bỏ trình quản lý front-end và fast table vốn là phần cốt lõi của phiên bản trước. Các tập hợp cấu trúc dữ liệu và thuật toán mới được gọi là Low Fragmentation Heap được giới thiệu như front-end heap. Và để thích ứng với trình quản lý heap front-end mới, cơ chế quản lý của trình quản lý heap back-end cũng khác với trình quản lý heap back-end của phiên bản trước.

Bắt đầu từ phiên bản này, cấu trúc của heap block được cấp phát cho người dùng bởi trình quản lý heap front-end đã được đổi thành UserBlocks, cái mà tương tự như Lookaside của phiên bản trước. Cấu trúc của heap block được cấp phát đến người dùng bởi trình quản lí heap back-end được thay đổi thành ListHints, cái mà tương tự như Freelist ở phiên bản trước. Ngoài ra, còn có một Freelists members trong HeapBase quản lý heap, khiến ta có thể nhầm lẫn với Freelist trong phiên bản trước. nó (Freelist**s**) là một danh sách các con trỏ liên kết đến tất cả các free heap được quản lý bởi HeapBase, điều đáng nói là một block của nó sẽ có đơn vị khác: 1 block = 8 byte.

#### 4.2.1 UserBlocks
Cấu trúc này nằm trong cấu trúc HeapBase(_HEAP)->FrontEndHeap(_LFH_HEAP)->LocalData(_HEAP_LOCAL_DATA)->SegmentInfo(_HEAP_LOCAL_SEGMENT_INFO)->ActiveSubsegment/Hint(_HEAP_SUBSEGMENT)

Do cấu trúc quản lý phức tạp của front-end heap nên trong bài báo này tác giả chỉ giải thích các thành viên quan trọng trong các cấu trúc quan trọng.

##### 4.2.1.1 _LFH_HEAP
Cấu trúc dữ liệu của _LFH_HEAP được biểu diễn như bên dưới:
```
0:007> dt _LFH_HEAP
ntdll!_LFH_HEAP
  +0x000 Lock                 : _RTL_CRITICAL_SECTION
  +0x018 SubSegmentZones      : _LIST_ENTRY
  +0x020 ZoneBlockSize        : Uint4B
  +0x024 Heap                 : Ptr32 Void
  +0x028 SegmentChange        : Uint4B
  +0x02c SegmentCreate        : Uint4B
  +0x030 SegmentInsertInFree  : Uint4B
  +0x034 SegmentDelete        : Uint4B
  +0x038 CacheAllocs          : Uint4B
  +0x03c CacheFrees           : Uint4B
  +0x040 SizeInCache          : Uint4B
  +0x048 RunInfo              : _HEAP_BUCKET_RUN_INFO
  +0x050 UserBlockCache       : [12] _USER_MEMORY_CACHE_ENTRY
  +0x110 Buckets              : [128] _HEAP_BUCKET
  +0x310 LocalData            : [1] _HEAP_LOCAL_DATA

```

Trong cấu trúc _LFH_HEAP, chúng ta chủ yêu quan tâm đến trường LocalData, trường này là một con trỏ chứa thông tin của từng SubSegment để duy trì UserBlocks.

##### 4.2.1.2 _HEAP_LOCAL_DATA
Cấu trúc của _HEAP_LOCAL_DATA như bên dưới:
```
0:007> dt _HEAP_LOCAL_DATA
ntdll!_HEAP_LOCAL_DATA
  +0x000 DeletedSubSegments  : _SLIST_HEADER
  +0x008 CrtZone             : Ptr32 _LFH_BLOCK_ZONE
  +0x00c LowFragHeap         : Ptr32 _LFH_HEAP
  +0x010 Sequence            : Uint4B
  +0x018 SegmentInfo         : [128] _HEAP_LOCAL_SEGMENT_INFO
```

_HEAP_LOCAL_DATA chứa một mảng SegmentInfo có kích thước là 128, mỗi phần tử trong mảng duy trì tất cả UserBlocks nhỏ hơn 16KB theo kích thước tương ứng trong mảng _RtlpBucketBlockSizes (không bao gồm kích thước của heap header):
``` c
int _RtlpBucketBlockSizes[128] = {
  0h,     8h,     10h,    18h,    20h,    28h,    30h,    38h,
  40h,    48h,    50h,    58h,    60h,    68h,    70h,    78h,
  80h,    88h,    90h,    98h,    0A0h,   0A8h,   0B0h,   0B8h,
  0C0h,   0C8h,   0D0h,   0D8h,   0E0h,   0E8h,   0F0h,   0F8h,
  100h,   110h,   120h,   130h,   140h,   150h,   160h,   170h,
  180h,   190h,   1A0h,   1B0h,   1C0h,   1D0h,   1E0h,   1F0h,
  200h,   220h,   240h,   260h,   280h,   2A0h,   2C0h,   2E0h,
  300h,   320h,   340h,   360h,   380h,   3A0h,   3C0h,   3E0h,
  400h,   440h,   480h,   4C0h,   500h,   540h,   580h,   5C0h,
  600h,   640h,   680h,   6C0h,   700h,   740h,   780h,   7C0h,
  800h,   880h,   900h,   980h,   0A00h,  0A80h,  0B00h,  0B80h,
  0C00h,  0C80h,  0D00h,  0D80h,  0E00h,  0E80h,  0F00h,  0F80h,
  1000h,  1100h,  1200h,  1300h,  1400h,  1500h,  1600h,  1700h,
  1800h,  1900h,  1A00h,  1B00h,  1C00h,  1D00h,  1E00h,  1F00h,
  2000h,  2200h,  2400h,  2600h,  2800h,  2A00h,  2C00h,  2E00h,
  3000h,  3200h,  3400h,  3600h,  3800h,  3A00h,  3C00h,  3E00h
}
```

Ví dụ, SegmentInfo[0] duy trì tất cả các heap block 0 byte trong vùng của user. Do khối heap block 0 byte không tồn tại nên SegmentInfo[0] không duy trì các heap block nào, ngược lại SegmentInfo[8] sẽ duy trì tất cả các heap block 0x40 bytes trong vùng của user.

##### 4.2.1.3 _HEAP_LOCAL_SEGMENT_INFO
Cấu trúc dữ liệu của SegmentInfo HEAP_LOCAL_SEGMENT_INFO được biểu diễn như bên dưới:
```
0:007> dt _HEAP_LOCAL_SEGMENT_INFO
ntdll!_HEAP_LOCAL_SEGMENT_INFO
  +0x000 Hint             : Ptr32 _HEAP_SUBSEGMENT
  +0x004 ActiveSubsegment : Ptr32 _HEAP_SUBSEGMENT
  +0x008 CachedItems      : [16] Ptr32 _HEAP_SUBSEGMENT
  +0x048 SListHeader      : _SLIST_HEADER
  +0x050 Counters         : _HEAP_BUCKET_COUNTERS
  +0x058 LocalData        : Ptr32 _HEAP_LOCAL_DATA
  +0x05c LastOpSequence   : Uint4B
  +0x060 BucketIndex      : Uint2B
  +0x062 LastUsed         : Uint2B
```

Hint và ActiveSubsegment là hai trường trực tiếp quản lý UserBlocks và được khởi tạo NULL. Trường Hint chỉ được gán sau khi heap được cấp phát bởi trình quản lý front_end free và trường ActiveSubsegment sẽ được gán khi yêu cầu cấp phát lần đầu tiên, cả hai trường sẽ bổ sung cho nhau. Để dễ trình bày, phần sau sẽ sử dụng trường Hint như một ví dụ để giải thích thêm.

Trường LocalData sẽ trỏ đến địa chỉ LocalData nơi quản lý SegmentInfo.

Trường BucketIndex cho biết kích thước block của block trong vùng user được duy trì bởi SegmentInfo.

##### 4.2.1.4 _HEAP_SUBSEGMENT
Cấu trúc dữ liệu của Hint _HEAP_SUBSEGMENT như sau:
```
0:007> dt _HEAP_SUBSEGMENT
ntdll!_HEAP_SUBSEGMENT
  +0x000 LocalInfo      : Ptr32 _HEAP_LOCAL_SEGMENT_INFO
  +0x004 UserBlocks     : Ptr32 _HEAP_USERDATA_HEADER
  +0x008 AggregateExchg : _INTERLOCK_SEQ
  +0x010 BlockSize      : Uint2B
  +0x012 Flags          : Uint2B
  +0x014 BlockCount     : Uint2B
  +0x016 SizeIndex      : UChar
  +0x017 AffinityIndex  : UChar
  +0x010 Alignment      : [2] Uint4B
  +0x018 SFreeListEntry : _SINGLE_LIST_ENTRY
  +0x01c Lock           : Uint4B
```

Trường LocalInfo trỏ đến địa chỉ SegmentInfo nơi quản lý Hint/ActiveSubsegment.

Trường UserBlock là phần đầu của user heap block. Ngay sau UserBlocks là vùng user được kết nối với kích thước cố định. Lấy heap block 0x30 (vùng user 0x28) được duy trì bởi  SegmentInfo[5]->Hint.UserBlocks làm ví dụ, memory space của nó sẽ như sau:

![SegmentInfo[5]->Hint.UserBlocks](pic/pic21.PNG)

Điều đáng nói là 2 byte đầu của vùng user của heap block ở trạng thái free sẽ lưu offset của free heap tiếp theo để tạo điều kiện cập nhật kịp thời trường FreeEntryOffset trong AggregateExchg được đề cập bên dưới khi đăng ký heap block

![SegmentInfo[5]->Hint.UserBlocks](pic/pic22.PNG)

Trường BlockSize chỉ ra rằng block size của một block (kể cả phần header) được duy trì bởi cấu trúc trên.

Trường BlockCount chỉ ra số lượng của tất cả các heap block được duy trì bởi cấu trúc trên.

Trường SizeIndex đại diện cho block sizre của vùng user của heap block được đề cập bởi cấu trúc trên, nó bằng mới BucketIndex (BucketIndex=SizeIndex=BlockSize-1).

Trường AggregateExchg trỏ đến cấu trúc _INTERLOCK_SEQ, cái nà được sử dụng để lập index với heap block tương ứng khi cấp phát và giải phóng heap block đó.

##### 4.2.1.5 _INTERLOCK_SEQ
Cấu trúc dữ liệu _INTERLOCK_SEQ của AggregateExchg như sau:
``` c
0:007> dt _INTERLOCK_SEQ
ntdll!_INTERLOCK_SEQ
  +0x000 Depth            : Uint2B
  +0x002 FreeEntryOffset  : Uint2B
  +0x000 OffsetAndDepth   : Uint4B
  +0x004 Sequence         : Uint4B
  +0x000 Exchg            : Int8B
```

Trường Depth ghi lại số lượng free heap blocks trong UserBlocks.

Trường FreeEntryOffset cho biết block size từ index của UserBlock header đến heap block được cấp phát, nghĩa là địa chỉ của heap block được cấp phát tiếp theo là UserBlocks+8*FreeEntryOffset.

#### 4.2.2 FreeLists
Là một cấu trúc nằm trong cấu trúc HeapBase (_HEAP).

##### 4.2.2.1 _LIST_ENTRY
cấu trúc _LIST_ENTRY của FreeLists như bên dưới:
```
0:004> dt _LIST_ENTRY
  +0x000 Flink    : Ptr32 _LIST_ENTRY
  +0x004 Blink    : Ptr32 _LIST_ENTRY
```

Là một cấu trúc tương đối đơn giản, Flink và Blink là con trỏ next và con trỏ previous. FreeLists là một danh sách liên kết đôi, liên kết toàn bộ các free heap block được cấp phát bởi backend được quản lý bởi HeapBase theo kích thước tăng dần.

#### 4.2.3 ListHints
Cấu trúc này nằm ở HeapBase(_HEAP)->BlocksIndex(_HEAP_LIST_LOOKUP)

##### 4.2.3.1 _HEAP_LIST_LOOKUP
Bên dưới là cấu trúc dữ liệu của _HEAP_LIST_LOOKUP quản lý cấu trúc ListHints:
```
0:001> dt _HEAP_LIST_LOOKUP
ntdll!_HEAP_LIST_LOOKUP
  +0x000 ExtendedLookup : Ptr32 _HEAP_LIST_LOOKUP
  +0x004 ArraySize : Uint4B
  +0x008 ExtraItem : Uint4B
  +0x00c ItemCount : Uint4B
  +0x010 OutOfRangeItems : Uint4B
  +0x014 BaseIndex : Uint4B
  +0x018 ListHead : Ptr32 _LIST_ENTRY
  +0x01c ListsInUseUlong : Ptr32 Uint4B
  +0x020 ListHints : Ptr32 Ptr32 _LIST_ENTRY
```

Sau đây tác giả sẽ giải thích các thành phần quan trọng trong cấu trúc trên ở giai đoạn này.

Nếu cấu trúc cần được mở rộng, ExtendedLookup sẽ trỏ đến một _HEAP_LIST_LOOKUP tiếp theo, ngược lại, nó sẽ là NULL.

ArraySize là block size lớn nhất mà ListHints có thể giải quyết trong cấu trúc này. Trong phiên bản tại giai đoạn này, ArraySize có giá trị 0x80 hoặc 0x800. Ví dụ, ArraySize trong HeapBase->BlocksIndex là 0x80, nếu có phần mở rộng, ArraySize trong cấu trúc được mở rộng là 0x800 (HeapBase->BlocksIndex->ExtendedLookup.ArraySize=0x800).

Giá trị ItemCount đại diện cho số free heap block trong cấu trúc _HEAP_LIST_LOOKUP.

Giá trị OutOfRangeItems đại diện cho số heap block có kích thước cao hơn ArraySize trong _HEAP_LIST_LOOKUP, nghĩa là số lượng heap block trong danh sách liên kết ListHints[ArraySize-BaseIndex-1] sẽ được đề cập tiếp theo. Ví dụ, nếu cấu trúc _HEAP_LIST_LOOKUP có phần mở rộng, OutOfRangeItems sẽ là 0.

Giá trị BaseIndex đại diện cho block size bắt đầu của _HEAP_LIST_LOOKUP. Ví dụ, giá trị này trong cấu trúc _HEAP_LIST_LOOKUP được lập index từ BlockIndex trong cấu trúc _HEAP là 0, và giá trị này trong cấu trúc _HEAP_LIST_LOOKUP được lập index từ ExtendedLookup trong cấu trúc _HEAP_LIST_LOOKUP là 0x80.

ListHead và HeapBase->FreeLists trỏ đến cùng một nơi, liên kết các con trỏ đến tất cả các free heap được quản lý bởi HeapBase.

ListsInUseUlong là một mảng, nó giống như một BitMap của ListHints.

ListHint cũng có một mảng cấu trúc _LIST_ENTRY, cấu trúc _LIST_ENTRY chỉ chiếm 8 bytes, gồm Flink và Blink, mỗi cái 4 byte. Số index của ListHints đại diện cho block size được quản lý bởi heap block. và mỗi Flink trỏ đến heap block đầu tiên có kích thước tương ứng trên chuỗi _HEAP->FreeLists. Blink thì khá đặc biệt, nó không trỏ đến địa chỉ của heap block, mà trỏ đến địa chỉ Bucket(_HEAP_BUCKET)+1 tương ứng với số index sau cơ chế phân bổ của LFH được kích hoạt cho kích thước của heap block. Khi cơ chế LFH không được kích hoạt, 2 byte đầu tiền của Blink đại diện cho 2 lần tổng số tất cả heap block ở trạng thái occupied có kích thước này, 2 byte cuối đại diện cho tổng số heap block được yêu cầu ở kích thước này. Ngoài ra, trong đề cập của bài viết trước, con trỏ Flink của ListHints[ArraySize-BaseIndex-1] sẽ trỏ đến free heap block đầu tiền, trong chuỗi FreeLists có block size lơn hơn ArraySize-1, tương tự Freelist[0] trong phiên bản trước.

Nhìn chung, ListHints của ListHints đóng vai trò FreeList của danh sách liên kết heap cache và Blink của ListHint đóng vai trò kết nối trình quản lý heap back-end và trình quản lý heap front-end, bởi vì nó đánh dấu xem heap block có kích thước tương ứng đã bật LFH hay chưa?

### 4.3 Heap block operation
#### 4.3.1 Heap block allocation
Khi heap block được yêu cầu, nó chủ yêu được cấp phát từ trình quản lý heap front-end và trình quản lý heap back-end được đề cập ở trên.

Khi một heap block được cấp phát từ trình quản lý heap front-end, người dùng sẽ đăng ký heap block size index để mảng SegmentInfo cung cấp một heap block có kích thước tương ứng tại trường SegmentInfo->Hint->AggregateExchg->OffsetAndDepth. Trong trường hợp Depth là non-zero, heap block ở địa chỉ UserBlocks+8*FreeEntryOffset sẽ được cấp phát đến người dùng và sau đó cập nhật trường FreeEntryOffset tại offset nằm ở 2 byte đầu tiên của vùng user trong heap block để thuận tiện cho việc đặt địa chỉ ở quá trình cấp phát tiếp theo và thiết lập Depth thành -1.

Khi một heap block được cấp phát từ trình quản lý heap back-end, user sẽ đăng ký heap block size index để mảng ListHints cung cấp một heap block có kích thước tương ứng trong danh sách liên kêt FreeLists, thông qua con trỏ Flink, quá trình Unlink thực hiện việc gõ bỏ heap block đó khỏi danh sách liên kết và cấp phát cho user. Nếu không tìm thấy heap block có kích thước tương ứng, nó sẽ duyệt ngược danh sách liên kết FreeLists đến khi nào gặp được heap block có kích thước nhỏ nhất phù hợp để cấp phát, sau đó nó lấy heap block đó ra và câp phát cho người dùng. Nếu duyệt hết toàn bộ FreeLists nhưng vẫn không tìm được, heap sẽ được mở rộng. Phiên bản này của trình quản lý heap back-end có cơ chế tương tự với phiên bản trước.

Khi người dùng đăng ký cấp phát một vùng nhớ có kích thước cố định, nếu nó lớn hơn 0xFE00 blocks (508KB), VirtualAlloc() được gọi để cấp phát. Nếu nó lớn hơn 0x800 block (16KB), trình quản lý heap back-end được sử dụng để cấp phát trực tiếp. Nếu nó nhỏ hơn 16KB, trình quản lý heap back-end sẽ trả lời cho việc cấp phát qua việc tìm kiếm kích thước tương ứng trong ListHints trong cấu trúc BlocksIndex và ExtendedLookup. Nếu tìm thấy mảng ListHints có kích thước tương ứng, nó sẽ xét xem Blink có phải là một số lẻ (Buckets +1). Nếu có, hoạt động cấp phát sẽ giao cho trình quản lý heap front-end làm. Nếu không phải số lẻ, nó sẽ xem xet 2 byte thấp của Blink có lớn hơn 0x20 hoặc 2 byte cao có lớn hơn 0x1000, nghĩa là xem xét tổng số lượng heap block có kích thước này ở trạng thái occupied có lớn hơn 0x10 (ở trên tác giá ghi 0x20, dưới đây là 0x10, không biết tác giả có viêt nhầm không) hoặc xem xét xem heap block ở kích thước này đã thực hiện được 0x1000 lần chưa. Nếu đúng, HeapBase->CompatibilityFlags sẽ được thiết lập, Blink sẽ được gán đến Buckets+1 khi heap block có cùng kích thước được cấp phát ở lần tiếp theo, và trình quản lý heap front-end sẽ được kích hoạt để cấp phát heap block, trình quản lý heap back-end vẫn được sử dụng để cấp phát heap block và thêm 0x10002 vào giá trị Blink.

#### 4.3.2 Heap block release
Khi thực hiện hoạt động giải phóng heap, hệ thống tuân theo quy tác **"đến từ đâu thì về chỗ ấy"**, khi nhận được yêu cầu giải phóng heap, trước tiên, hệ thống xác định kích thước của heap block đó. Tất cả các heap block có kích thước lơn hơn 508KB sẽ được giải phóng trực tiếp qua việc gọi VirtualFree(), heap block nhỏ hơn 508KB nhưng lớn hơn 16KB sẽ được kết nối với danh sách liên kết FreeLists. Còn đối với các heap block nhỏ hơn 16KB, hệ thống sẽ sử dụng thông tin header của nó để xác định xem nó được cấp phát từ vùng quản lý của front-end hay từ vùng quản lý của back-end. Nếu được cấp phát từ front-end, nó sẽ được giải phóng về front-end heap AggregateExchg và FreeEntryOffset trong cấu trúc này được ghi 2 byte đầu tiên trong vùng user của heap block, trường FreeEntryOffset ở offset của heap block đó ...... , trường Depth là +1. Nếu cấp phát từ backend, liên kết nó với danh sách liên kết FreeLists và cập nhật con trỏ Flink trong ListHint có kích thước tương ứng, sau đó xem xét xem LFH có kích thước tương ứng có được thiết lập không, nếu không, set Blink 0x0002

#### 4.3.3 Heap block merge
Việc hợp các heap block trong giai đoạn này hầu hết giống với giai đoạn trước. Khi front-end heap block được giải phóng, hoạt động hơp nhất sẽ không được kích hoạt. Khi back-end heap block được giải phóng, nếu có một free heap block liền kề với nó, hoạt động hợp nhất sẽ được tiến hành, heap block được hợp nhất sẽ liên kết với FreeLists thích hợp với kích thước của nó và cập nhật ListHints tương ứng với kích thước.

### 4.4 Protection mechanism
Tại giai đoạn này, hệ điều hành Windows được giới thiệu một số cơ chế bảo vệ bổ sung ngoài việc kế thừa các cơ chế bảo vệ của giai đoạn trước trong việc bảo vệ heap như heap base address randomization, heap header encoding, Safe Link,... Việc ra mắt các cơ chế bảo vệ này đã giúp lỗ hỏng heap của hệ điều hành Windows trở nên khó khai thác hơn.

#### 4.4.1 Randomization of heap base address
Cơ chế căn chỉnh nẫu nhiên địa chỉ Heapbase sao cho địa chỉ là bội số của 64KB khi heap được tạo, nghĩa là làm sao để 4 bytes thấp của heap base là 0. Sự ngẫu nhiên của địa chỉ heap base tương tự như sự ngẫu nhiên của địa chỉ stack base. Với mục địch là làm cho địa chỉ sau mỗi lần tạo là khác nhau, gây khó cho kẻ tấn công muốn khai thác heap vì họ cần phải biết địa chỉ này. Tham khảo thêm: [Are Heap addresses randomized by ASLR?](https://security.stackexchange.com/questions/123860/are-heap-addresses-randomized-by-aslr) và [Heap randomization in Windows](https://stackoverflow.com/questions/1232081/heap-randomization-in-windows).

#### 4.4.2 Header coding
Như đã nói, cơ chế bảo vệ quan trọng của heap ở phiên bản trước là Heap Cookie. Tuy nhiên, qua thực tế, 1 byte của Heap Cookies không đủ đẻ ngăn chặn kẻ tấn công giả mạo dữ liệu nhạy cảm trên heap header

Để bảo vệ thông tin nhạy cảm của heap header khỏi bị kẻ tấn công giả mạo. Windows đã ra mắt cơ chế bảo vệ mã hóa heap header trong giai đoạn này. Trước khi nói về cơ chế này, ta sẽ nói sơ về cầu trúc của _HEAP_ENTRY trong heap header trước:
```
0:001> dt _HEAP_ENTRY
ntdll!_HEAP_ENTRY
  +0x000 Size : Uint2B
  +0x002 Flags : UChar
  +0x003 SmallTagIndex : Uchar
  +0x000 SubSegmentCode : Ptr32 Void
  +0x004 PreviousSize : Uint2B
  +0x006 SegmentOffset : Uchar
  +0x006 LFHFlags : Uchar
  +0x007 UnusedBytes : Uchar
```

Cơ chế mã hóa heap header đầu tiên xác định xem cơ chế mã hóa heap header đã được thiết lập trong vùng heap. Nếu nó được thiết lập, 3 byte đầu tiên đại diện cho Size, Flag sẽ được XOR từng byte một, sau đó được gán vào SmallTagIndex, tại mỗi Heap Base khác nhau sẽ tạo ra một HeapBase->Encoding ngẫu nhiên, để mã hóa heap header thông qua việc XOR. Mã giả của thuật toán mã hóa header như sau:
``` c
// EncodeHeader algorithm
void EncodeHeader(_HEAP_ENTRY *Header, _HEAP *HeapBase) {
	if (HeapBase->EncodeFlagMask) {
		Header->SmallTagIndex = (byte)Header ^ ((Byte)Header + 1) ^ ((Byte)Header + 2);
		(DWORD)Header ^= HeapBase->Encoding;
	}
}
```

Khi giải mã, nó sẽ xem xét xem header có được mã hóa hay không. Nếu nó được mã hóa, header sẽ được XOR với HeapBase->Encoding để có được heap header thật. Thuật toán decode được biểu dưới dạng mã giả sau:
``` c
// DecodeHeader algorithm
void DecodeHeader(_HEAP_ENTRY *Header, _HEAP *HeapBase) {
	if(HeapBase->EncodeFlagMask && (Header & HeapBase->EncoderFlagMask)) {
		(DWORD)Header ^= HeapBase->Encoding;
	}
}
```

Sau khi cơ chế này xuất hiện, kẻ tấn công đã khó khăn trong việc sửa đổi thông tin nhạy cảm trên header như Size, Flag mà không bị phát hiện. Điều đó cho thấy cơ chế bảo vệ này hiệu quả hơn cơ chế Heap Cookie ở phiên bản trước.

#### 4.4.3 Safe Link
Như đề cập ở trên, sau khi ra mắt cơ chế Safe Unlink trong phiên bản windows trước, kẻ tấn công đã phát hiện và khai thác lỗ hỏng của quá trình thực hiện Link (liên kết). Để cải thiện cơ chế bảo vệ khi vận hành danh sách liên kết, Windows đã ra mắt cơ chế bảo vệ Safe Link trong giai đoạn này. Cơ chế này sẽ xem xét xem liệu Flink và Blink tại liên kết sắp bị ngắt là hợp lệ trước khi liên kết heap block vào trong danh sách liên kết. Nếu hợp lệ, nó sẽ thực hiện hoạt động Link, ngược lại, nó sẽ gọi RtlpLogHeapFailure() để kết thúc chương trình. Mã giả của thuật toán Safe Link như sau:
``` c
// Safe Link algorithm
void Safe_ReLink(_LIST_ENTRY *ChunkToFree, _LIST_ENTRY *InsertList) {
	if (InsertList>Blink->Flink) {
		ChunkToFree->Flink = InsertList;
		ChunkToFree->Blink - InsertList->Blink;
		InsertList->Blink->Flink = ChunkToFree;
		InsertList->Blink = ChunkToFree;
	}
	else {
		RtlpLogHeapFailure();
	}
}
```

#### 4.4.4 HeapEnableTerminateOnCorrupton
Như đề cập ở trên, cơ chế bảo vệ được thêm vào ở phiên bản trước, RtlpHeapReportCorruption() sẽ được gọi khi phát hiện giả mạo. Tuy nhiên, do HeapEnableTerminateOnCorrupto không được bật mặc định, chương trình vẫn sẽ tiếp tục sau khi phát hiện giả mạo, dẫn đến việc tồn tại nhiều lỗ hổng được đề ở trên. Vì vậy mà trong giai đoạn này, trường HeapEnableTerminateOnCorrupto đã được thiết lập mặc định, tiến trình sẽ dừng ngay lập tức khi kẻ tấn công không vượt qua được cơ chế bảo mật, các phương thức tấn công ở giai đoạn trước đã không thể sử dụng cho giai đoạn này.

### 4.5 Exploit
Trong giai đoạn này, cơ chế quản lý heap của windows đã được sửa đổi, nhiều cấu trúc dữ liệu và một vài cơ chế bảo mật mới đã được thêm vào. Đây là cột mốc đánh dấu sự phát triển bảo mật của hệ điều hành Windows đối với các lỗ hỏng heap. Việc khai thác heap là một chuyện trở nên rất khó khăn.

#### 4.5.1 Break through the heap header encoding
Trong nhiều cơ chế bảo mật được thêm vào ở giai đoạn này, cơ chế mã hóa heap là một cơ chế then chốt. Hầu hết các phương thức khai thác trước đây đều dựa trên việc overflow heap block liền kề, lúc đó Heap Cookie chỉ là 1-bytes nên kẻ tấn công có thể thực hiện nhiều lần để bypass và giả mạo thông tin nhạy cảm của heap header. Trong giai đoạn này, cơ chế mã hóa được ra mắt, khiến tất cả thông tin trên heap header được mã hóa, ngăn chặn gần như hoàn toàn việc giả mạo thông tin nhạy cảm trên heap header bao gồm cả việc giá mạo con trỏ prev và next

Tuy nhiên, phân tích thuật toán heap header encoding (mã giả EncodeHeader algorithm ở trên), có thể thấy thông tin header được mã hóa bằng XOR và hoạt động XOR có thể đảo ngược. Nếu chúng ta có thể leak được heap header sau khi mã hóa, chúng ta sẽ biết được trạng thái của heap block. Nghĩa là chúng ta đã biết 3 byte đầu được XOR từng byte một và gán vào byte thứ tư SmallTagIndex trong phần này, 4 byte đầu đó sẽ được XOR với header được mã hóa đã leak được để lấy được giá trị HeapBase->Encoding

Mặc dù việc này không hoàn toàn là một cách khai thác lỗ hỏng trên heap, việc lấy được HeapBase->Encoding thông qua việc này sẽ giúp cho việc xây dựng các heap header phục vụ cho việc khai thác các lỗ hỏng khác. Việc này sẽ giúp các phương thức tấn công khác trở nên đỡ khó khăn hơn.

#### 4.5.2 LFH FreeEntryOffset OverFlow
##### 4.5.2.1 Causes of vulnerabilities
Như đề cập ở trên, trình quản lí heap front-end mới LFH được ra mắt trong phiên bản của giai đoạn này, 2 bytes đầu tiền của mỗi heap block tại vùng user chứa giá trị offset có thể được dùng để cập nhật trường FreeEntryOffset. Trường FreeEntryOffset đóng vai trò vô cùng quan trọng trong việc phân bổ địa chỉ heap của trình quản lý heap front-end.

Sau khi Break through the heap header encoding, 2 byte đầu của vùng user của free heap block được quản lí bởi trình quản lý heap front-end là khá mong manh và có thể bị ghi đè, khiến quá trình phân bổ của trình quản lý heap front-end bị cướp, dễ xảy ra các lỗ hỏng khác.

##### 4.5.2.2 How to use
Trước khi nói về phương thức khai thác, ta sẽ nói chi tiết về các hoạt động của các trường trong cấu trúc _INTERLOCK_SEQ của quá trình phân bổ heap block. Ta sẽ lấy UserBlocks có BlockSize là 6, nghĩa là 0x30 bytes để làm ví dụ:

Đầu tiên khởi tạo UserBlock có kích trên, trường FreeEntryOffset sẽ có giá trị là 0x2, vì sizeof (_HEAP_USERDATA_HEADER) bằng 0x10. [0x2 * 0x8 == 0x10].

FreeEntryOffset - Số nguyên 2 byte này giữ một giá trị, khi được thêm vào địa chỉ của _HEAP_USERDATA_HEADER, nó trỏ trỏ một đến vị trí tiếp theo để giải phóng hoặc cấp phát bộ nhớ. Giá trị này được biểu diễn dưới dạng block (chunk 0x8 byte) và được khởi tạo là 0x2, vì sizeof (_HEAP_USERDATA_HEADER) bằng 0x10. [0x2 * 0x8 == 0x10]. trường Depth sẽ tính toán bởi UserDataAllocSize để lấy số lượng heap block trong kích thước này. Giá trị của nó được khởi tạo bằng kích thước của UserBlock chia cho kích thước HeapBucket (Depth=(UserDataAllocSize-sizeof(_HEAP_USERDATA_HEADER)/BlockSize). Trong ví dụ này sẽ lấy Depth = 0x2A:

![LFH FreeEntryOffset OverFlow(1)](pic/pic23.PNG)

Tại đây, ta đăng ký một heap block 0x28 bytes đầu tiên (tính luôn header là 0x30 bytes), heap block được trỏ bởi trường FreeEntryOffset sẽ được cấp phát cho user thông qua trình quản lý heap front-end và FreeEntryOffset sẽ được cập nhật ở 2 bytes đầu của vùng user của heap block vừa được cấp phát (2 bytes đầu lưu trữ offset được sử dụng như địa chỉ cho heap block tiếp theo), trường Depth sẽ trừ đi 1 (-1):

![LFH FreeEntryOffset OverFlow(1)](pic/pic24.PNG)

Tương tự, ta tiếp tục cấp đăng ký thêm 2 heap block có kích thước 0x28 bytes (tổng là 3 heap block):

![LFH FreeEntryOffset OverFlow(1)](pic/pic25.PNG)

Lúc này, nếu ta yêu cầu giải phóng heap block thứ 2, giá trị FreeEntryOffset sẽ được lưu trữ vào 2 bytes đầu tiên của vùng user của heap block được giải phóng và được xem là offset, sau đó FreeEntryOffset sẽ được cập nhật theo độ lệch của heap block đó với _HEAP_USERDATA_HEADER, giá trị của trường Depth sẽ cộng thêm 1 (+1).

![LFH FreeEntryOffset OverFlow(1)](pic/pic26.PNG)

Ta có thể thấy rằng, giá trị offset ở 2 bytes đầu tiên của vùng user của free heap block quan trọng thế nào với thuật toán cấp phát và giải phóng heap block của trình quản lý heap front-end. Nếu ta có thể overflow heap block chứa offset chuyển đến con trỏ virtual table function, sau đó đăng ký một heap block và sửa đổi con trỏ virtual table function để chiếm quyền điều khiển chương trình.

Tiếp tục, ta sẽ thực hiện kịch bản khai thác như sau: heap block đầu tiên được sử dụng để overflow heap block, và heap block thứ ba được sử dụng để chứa con trỏ virtual table function:

![LFH FreeEntryOffset OverFlow(1)](pic/pic27.PNG)

Tại lúc này, ta overflow để thay đổi offset 2 byte đầu của free heap block thứ 2, sửa đổi giá trị thành Offset của heap block thứ ba (0xE - theo ví dụ này):

![LFH FreeEntryOffset OverFlow(1)](pic/pic28.PNG)

Sau đó thực hiện đăng ký một heap block có kích thước 0x28 bytes, thuật toán của trình quản lý heap front-end sẽ cập nhật FreeEntryOffset thành giá trị Offset giả (0xE)

![LFH FreeEntryOffset OverFlow(1)](pic/pic29.PNG)

Ta tiếp tục đăng ký một heap block có kích thước 0x28 bytes, thuật toán của trình quản lý heap front-end sẽ cấp phát heap block thứ ba và cập nhật FreeEntryOffset thành giá trị 2 bytes đầu của Vtable_ptr.

![LFH FreeEntryOffset OverFlow(1)](pic/pic30.PNG)

Cuối cùng, sẽ có 2 con trỏ trỏ tới heap block thứ ba, sửa đổi thích hợp, giá trị con trỏ virtual table function có thể chứa địa chỉ bất kỳ.




